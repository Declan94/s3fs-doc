<!--Copyright 2017 Declan Chen <chenye94@qq.com>-->

<!--This file is part of s3fs-doc.-->

<!--s3fs-doc is free software: you can redistribute it and/or modify-->
<!--it under the terms of the GNU General Public License as published by-->
<!--the Free Software Foundation, either version 3 of the License, or-->
<!--(at your option) any later version.-->

<!--s3fs-doc is distributed in the hope that it will be useful,-->
<!--but WITHOUT ANY WARRANTY; without even the implied warranty of-->
<!--MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the-->
<!--GNU General Public License for more details.-->

<!--You should have received a copy of the GNU General Public License-->
<!--along with s3fs-doc.  If not, see <http://www.gnu.org/licenses/>.-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>S3fs Doc - fdcache.h/cpp</title>

    <link type="text/css" href="bootstrap.min.css" rel="stylesheet" />
    <link type="text/css" href="main.css" rel="stylesheet" />
</head>
<body>
<div class="container-fluid">
    <h2 class="top">S3fs Doc - fdcache.h/cpp</h2>

    <div class="section" id="FdManager">
        <h3>FdManager</h3>

        <div class="attrs">
            <div class="attr" id="FdManager-fent">
                <div class="name"><code>std::map&lt;std::string, class FdEntity*&gt; fent;</code></div>
                <div class="desc">
                    FdEntity map, [path] -> [FdEntity object].
                    NoCache模式下, path是随机的tmppath. 否则path是object实际路径
                </div>
            </div>
            <div class="attr" id="FdManager-cache_dir">
                <div class="name"><code>static std::string cache_dir;</code></div>
                <div class="name"><code>static const char* GetCacheDir(void) { return FdManager::cache_dir.c_str(); }</code></div>
                <div class="desc">
                    缓存路径
                </div>
            </div>
        </div>

        <div class="func" id="FdManager-SetCacheDir">
            <div class="name"><code>bool FdManager::SetCacheDir(const char* dir)</code></div>
            <div class="desc">
                静态方法, 设置缓存目录.
            </div>
            <ul class="impl">
                <li>如果<code>dir</code>为空指针或空字符串,<a href="#FdManager-cache_dir"><code>cache_dir = ""</code></a></li>
                <li>否则
                    <ul>
                        <li>检查<code>dir</code>为目录, <code>stat(dir, &st); S_ISDIR(st.st_mode)</code></li>
                        <li><a href="#FdManager-cache_dir"><code>cache_dir = dir</code></a></li>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="func" id="FdManager-IsSafeDiskSpace">
            <div class="name"><code>bool FdManager::IsSafeDiskSpace(const char* path, size_t size)</code></div>
            <div class="desc">
                静态方法, 检查磁盘空间
            </div>
        </div>

        <div class="func" id="FdManager-DeleteCacheDirectory">
            <div class="name"><code>bool FdManager::DeleteCacheDirectory(void)</code></div>
            <div class="desc">
                静态方法, 清空缓存目录.
            </div>
            <ul class="impl">
                <li>如果<a href="#FdManager-cache_dir"><code>cache_dir</code></a>为空, 说明是no cache模式, 返回true</li>
                <li>构造缓存目录路径<a href="#FdManager-MakeCachePath"><code>FdManager::MakeCachePath(NULL, cache_dir, false)</code></a></li>
                <li>清空缓存目录<a><code>delete_files_in_dir(cache_dir.c_str(), true)</code></a></li>
            </ul>
        </div>

        <div class="func" id="FdManager-MakeCachePath">
            <div class="name"><code>bool FdManager::MakeCachePath(const char* path, string& cache_path, bool is_create_dir, bool is_mirror_path)</code></div>
            <div class="desc">
                静态方法, 构造缓存路径. <br/>
                <code>path</code> 目标文件路径 <br/>
                <code>cache_path</code> 缓存路径(用于返回) <br/>
                <code>is_create_dir</code> default true, 是否新建路径上的文件夹 <br/>
                <code>is_mirror_path</code> default false <br/>
            </div>
            <ul class="impl">
                <li>如果<a href="#FdManager-cache_dir"><code>cache_dir</code></a>为空, 说明是no cache模式, <code>cache_path = ""</code>直接返回</li>
                <li>如果<code>is_mirror_path</code>, 构造路径为[cache_dir]/.[bucket].mirror/[path]</li>
                <li>如果<code>!is_mirror_path</code>, 构造路径为[cache_dir]/.[bucket]/[path]</li>
                <li>如果<code>is_create_dir</code>, 新建路径上的文件夹 <a><code>mkdirp(resolved_path + mydirname(path), 0777)</code></a></li>
            </ul>
        </div>

        <div class="func" id="FdManager-Open">
            <div class="name"><code>FdEntity* FdManager::Open(const char* path, headers_t* pmeta, ssize_t size, time_t time, bool force_tmpfile, bool is_create)</code></div>
            <div class="desc">
                打开并返回一个FdEntity对象 <br/>
                <code>path</code> object路径 <br/>
                <code>pmeta</code> object的meta <br/>
                <code>size</code> default -1 <br/>
                <code>time</code> default -1 <br/>
                <code>force_tmpfile</code> default false <br/>
                <code>is_create</code> default false 当前没有对应的FdEntity时是否新建<br/>
            </div>
            <ul class="impl">
                <li>在<a href="#FdManager-fent"><code>fent</code></a>中寻找path对应的FdEntity对象ent</li>
                <li>如果未找到, is_create为false则返回NULL, 为true则新建FdEntity如下
                    <ul>
                        <li>构造缓存路径并创建其父目录<a href="#FdManager-MakeCachePath"><code>FdManager::MakeCachePath(path, cache_path, true)</code></a></li>
                        <li>新创建FdEntity对象. <a href="#FdEntity-FdEntity"><code>ent = new FdEntity(path, cache_path.c_str())</code></a></li>
                        <li>将FdEntity对象存到<a href="#FdManager-fent"><code>fent</code></a>中,
                            如果cache_path为空(即不缓存模式), key通过<a href="#FdManager-MakeCachePath"><code>FdManager::MakeRandomTempPath(path, tmppath)</code></a>产生.
                            否则key即为<code>path</code>
                        </li>
                    </ul>
                </li>
                <li>执行FdEntity对象的打开方法. <a href="#FdEntity-Open"><code>ent->Open(pmeta, size, time)</code></a></li>
            </ul>
        </div>

        <div class="func" id="FdManager-ExistOpen">
            <div class="name"><code>FdEntity* FdManager::ExistOpen(const char* path, int existfd, bool ignore_existfd)</code></div>
            <div class="desc">
                打开一个已经存在的FdEntity. <br/>
                <code>path</code> 文件路径 <br/>
                <code>existfd</code> default -1.
                <code>ignore_existfd</code> default false.
            </div>
            <ul class="impl">
                <li>根据路径<code>path</code>查找已经存在的FdEntity并打开. <a href="#FdManager-Open"><code>FdEntity* ent = Open(path, NULL, -1, -1, false, false);</code></a></li>
                <li>如果上述结果返回NULL, 且<code>existfd</code>被设置, 或者<code>ignore_existfd</code>为真.
                    <ul>
                        <li>遍历<a href="#FdManager-fent"><code>fent</code></a>, 查找某一个打开的FdEntity, 其fd与<code>existfd</code>相等. 或者<code>ignore_existfd</code>为真</li>
                        <li>检查该FdEntity的<code>path</code>是否与给定的<code>path</code>一致, 一致则打开并返回.</li>
                    </ul>
                </li>
            </ul>
            <div class="remark">
                existfd和ignore_existfd的意义还未弄明白.
            </div>
        </div>

        <div class="func" id="FdManager-Close">
            <div class="name"><code>bool FdManager::Close(FdEntity* ent)</code></div>
            <div class="desc">
                关闭FdEntity
            </div>
            <ul class="impl">
                <li>如果<code>ent</code>为空指针, 直接返回true</li>
                <li>遍历<a href="#FdManager-fent"><code>fent</code></a>, 查找<code>ent</code>, 找到后,
                    <ul>
                        <li><a href="#FdEntity-Close"><code>ent->Close()</code></a></li>
                        <li>如果文件被彻底关闭(引用为0导致) (<a href="#Fdentity-IsOpen"><code>!ent->IsOpen()</code></a>),
                            <ul>
                                <li>从<code>fent</code>中清除该元素 <code>fent.erase(iter++)</code></li>
                                <li>为安全起见, 继续查找<code>fent</code>中是否有其它key对应该<code>ent</code>, 若存在同样清除</li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="func" id="FdManager-MakeRandomTempPath">
            <div class="name"><code>bool FdManager::MakeRandomTempPath(const char* path, string& tmppath)</code></div>
            <div class="desc">
                随机一个临时路径. <br />
                when not using cache, the key of fdentity in <a href="#FdManager-fent"><code>fent</code></a> is set not really existing path. (but not strictly unexisting path.)
            </div>
            <ul>
                <li>生成前缀<code>sprintf(szBuff, NOCACHE_PATH_PREFIX_FORM, random());</code></li>
                <li>如果<code>path</code>非空, 在后面加上<code>path</code></li>
            </ul>
            <div class="remark">
                关于<code>NOCACHE_PATH_PREFIX_FORM</code>:
<pre>//------------------------------------------------
// FdManager symbol
//------------------------------------------------
// [NOTE]
// NOCACHE_PATH_PREFIX symbol needs for not using cache mode.
// Now s3fs I/F functions in s3fs.cpp has left the processing
// to FdManager and FdEntity class. FdManager class manages
// the list of local file stat and file descriptor in conjunction
// with the FdEntity class.
// When s3fs is not using local cache, it means FdManager must
// return new temporary file descriptor at each opening it.
// Then FdManager caches fd by key which is dummy file path
// instead of real file path.
// This process may not be complete, but it is easy way can
// be realized.
//
#define NOCACHE_PATH_PREFIX_FORM    " __S3FS_UNEXISTED_PATH_%lx__ / "      // important space words for simply
</pre>
            </div>
        </div>

        <div class="func" id="FdManager-ChangeEntityToTempPath">
            <div class="name"><code>bool FdManager::ChangeEntityToTempPath(FdEntity* ent, const char* path)</code></div>
            <div class="desc">
                将<code>ent</code>在<a href="#FdManager-fent"><code>fent</code></a>中的key换成temp path
            </div>
            <ul class="impl">
                <li>遍历<a href="#FdManager-fent"><code>fent</code></a>找到<code>ent</code></li>
                <li><code>fent.erase(iter++)</code></li>
                <li><a href="#FdManager-MakeRandomTempPath"><code>FdManager::MakeRandomTempPath(path, tmppath)</code></a></li>
                <li><code>fent[tmppath] = ent</code></li>
            </ul>
            <div class="remark">
                找到ent后并没有退出循环, 而是继续遍历, 难道fent中会有多个同样的ent元素? 而且这个函数永远返回false.
            </div>
        </div>

    </div>

    <div class="section" id=FdEntity>
        <h3>FdEntity</h3>

        <div class="attrs">
            <div class="attr"><code>typedef std::vector&lt;std::string&gt; etaglist_t</code></div>

            <div class="attr" id="FdEntity-pagelist"><span class="name"><code>PageList        pagelist;        </code></span>// 分页表, 用于标记文件个部分的加载状态. </div>
            <div class="attr" id="FdEntity-refcnt"><span class="name"><code>int             refcnt;          </code></span>// reference count, 引用数 </div>
            <div class="attr" id="FdEntity-path"><span class="name"><code>std::string     path;            </code></span>// object path, 路径 </div>
            <div class="attr" id="FdEntity-cachepath"><span class="name"><code>std::string     cachepath;       </code></span>// local cache file path (if this is empty, does not load/save pagelist.)</div>

            <div class="attr" id="FdEntity-mirrorpath"><span class="name"><code>std::string     mirrorpath;      </code></span>// mirror file path to local cache file path </div>
            <div class="attr" id="FdEntity-fd"><span class="name"><code>int             fd;              </code></span>// file descriptor(tmp file or cache file) </div>
            <div class="attr" id="FdEntity-pfile"><span class="name"><code>FILE*           pfile;           </code></span>// file pointer(tmp file or cache file) </div>
            <div class="attr" id="FdEntity-is_modify"><span class="name"><code>bool            is_modify;       </code></span>// if file is changed, this flag is true, 标记文件local版本和云端版本是否有差别 </div>
            <div class="attr" id="FdEntity-orgmeta"><span class="name"><code>headers_t       orgmeta;         </code></span>// original headers at opening 云端存储的object meta</div>
            <div class="attr" id="FdEntity-size_orgmeta"><span class="name"><code>size_t          size_orgmeta;    </code></span>// original file size in original headers 云端文件的大小 </div>

            <div class="attr" id="FdEntity-upload_id"><span class="name"><code>std::string     upload_id;       </code></span>// for no cached multipart uploading when no disk space </div>
            <div class="attr" id="FdEntity-etaglist"><span class="name"><code>etaglist_t      etaglist;        </code></span>// for no cached multipart uploading when no disk space </div>
            <div class="attr" id="FdEntity-mp_start"><span class="name"><code>off_t           mp_start;        </code></span>// start position for no cached multipart(write method only) </div>
            <div class="attr" id="FdEntity-mp_size"><span class="name"><code>size_t          mp_size;         </code></span>// size for no cached multipart(write method only) </div>

        </div>

        <div class="func" id="FdEntity-FdEntity">
            <div class="name"><code>FdEntity::FdEntity(const char* tpath, const char* cpath)</code></div>
            <div class="desc">
                FdEntity构造函数 <br/>
                <code>tpath</code> 目标object的路径 <br/>
                <code>cpath</code> 缓存路径 <br/>
            </div>
            <ul class="impl">
                <li>初始化成员变量
                    <ul>
                        <li><a href="#FdEntity-refcnt"><code>refcnt</code></a>初始化为0</li>
                        <li><a href="#FdEntity-path"><code>path</code></a>初始化为<code>tpath</code>或空字符串(当tpath为NULL时)</li>
                        <li><a href="#FdEntity-cachepath"><code>cachepath</code></a>初始化为<code>cpath</code>或空字符串(当cpath为NULL时)</li>
                        <li><a href="#FdEntity-mirrorpath"><code>mirrorpath</code></a>初始化为空字符串""</li>
                        <li><a href="#FdEntity-fd"><code>fd</code></a>初始化为-1</li>
                        <li><a href="#FdEntity-pfile"><code>pfile</code></a>初始化为NULL</li>
                        <li><a href="#FdEntity-is_modify"><code>is_modify</code></a>初始化为false</li>
                        <li><a href="#FdEntity-size_orgmeta"><code>size_orgmeta</code></a>初始化为0</li>
                        <li><a href="#FdEntity-upload_id"><code>upload_id</code></a>初始化为空字符串""</li>
                        <li><a href="#FdEntity-mp_start"><code>mp_start</code></a>初始化为0</li>
                        <li><a href="#FdEntity-mp_size"><code>mp_size</code></a>初始化为0</li>
                    </ul>
                </li>
                <li>初始化线程锁, 类型设置为<code>S3FS_MUTEX_RECURSIVE</code></li>
            </ul>
        </div>

        <div class="func" id="FdEntity-Open">
            <div class="name"><code>int FdEntity::Open(headers_t* pmeta, ssize_t size, time_t time)</code></div>
            <div class="desc">
                <code>pmeta</code> 最新获取的object的原始meta信息 <br/>
                <code>size</code> default -1 <br/>
                <code>time</code> default -1, 表示不修改 <br/>
            </div>
            <ul class="impl">
                <li>如果<a href="#FdEntity-fd"><code>fd</code></a>不为-1, 说明已经打开了本地文件.
                    <ul>
                        <li>增加<a href="#FdEntity-refcnt"><code>refcnt</code></a>, <a href="#FdEntity-Dup"><code>Dup()</code></a></li>
                        <li>检查size是否变动, 如果变动
                            <ul>
                                <li><code>ftruncate(fd, static_cast&lt;size_t&gt;(size))</code></li>
                                <li><a href="#PageList-Resize"><code>pagelist.Resize(static_cast&lt;size_t&gt;(size), false)</code></a></li>
                            </ul>
                        </li>
                        <li>
                            更新<a href="#FdEntity-orgmeta"><code>orgmeta</code></a>和<a href="#FdEntity-size_orgmeta"><code>size_orgmeta</code></a>
                            <ul>
                                <li>如果<code>pmeta</code>非空, newsize从<code>pmeta</code>中获取('Content-Length'字段).
                                    否则如果<code>size</code>大于0, 则newsize设置为<code>size</code>
                                </li>
                                <li>如果newsize < size_orgmeta, 则更新<a href="#FdEntity-size_orgmeta"><code>size_orgmeta</code></a>为newsize. (为什么加前面的条件?)</li>
                                <li>如果<code>pmeta</code>非空, 更新<a href="#FdEntity-orgmeta"><code>orgmeta</code></a>为pmeta</li>
                            </ul>
                        </li>
                        <li>返回0, 不用执行后续操作</li>
                    </ul>
                </li>
                <li>如果是有缓存目录的模式,
                    <ul>
                        <li><a href="#CacheFileStat-CacheFileStat"><code>CacheFileStat cfstat(path.c_str())</code></a> </li>
                        <li>打开缓存文件<code>fd = open(cachepath.c_str(), O_RDWR)</code>和缓存stat文件<a href="#PageList-Serialize"><code>pagelist.Serialize(cfstat, false)</code></a></li>
                        <li>如果打开成功, 根据原有的缓存文件的信息进行操作.
                            <ul>
                                <li>获取缓存文件的attr <code>fstat(fd, &st)</code></li>
                                <li>如果<code>size == -1</code>, 则<code>size = static_cast&lt;ssize_t&gt;(st.st_size)</code></li>
                                <li>如果<a href="#PageList-Size"><code>size != pagelist.Size()</code></a>, 则重置<code>pagelist</code>的大小.
                                    <a href="#PageList-Resize"><code>pagelist.Resize(static_cast&lt;size_t&gt;(size), false)</code></a>
                                </li>
                                <li>如果<code>size</code>与<code>st.size</code>不一致, 对缓存文件执行truncate操作.
                                    <ul>
                                        <li><code>ftruncate(fd, static_cast&lg;off_t&gt;(size))</code></li>
                                        <li><code>fsync(fd)</code></li>
                                    </ul>
                                </li>
                            </ul>
                        </li>
                        <li>如果打开失败, 初始化缓存文件.
                            <ul>
                                <li>新建并打开缓存文件. <code>fd = open(cachepath.c_str(), O_CREAT|O_RDWR|O_TRUNC, 0600)</code></li>
                                <li>如果<code>size</code>为-1, 则改为0, 并初始化分页表. <a href="#PageList-Init"><code>size = 0; pagelist.Init(0, false)</code></a></li>
                                <li>如果<code>size</code>不为-1, 则调整分页表大小, <a href="#PageList-Resize"><code>pagelist.Resize(static_cast&lt;size_t&gt;(size), false)</code></a>.
                                    并且对缓存文件执行truncate操作. </li>
                            </ul>
                        </li>
                        <li><a href="#FdEntity-OpenMirrorFile"><code>mirrorfd = OpenMirrorFile()</code></a></li>
                        <li><code>close(fd); fd = mirrorfd;</code></li>
                        <li><code>pfile = fdopen(fd, "wb");</code></li>
                    </ul>
                </li>
                <li>如果是没有缓存目录的模式,
                    <ul>
                        <li>打开一个临时文件<code>pfile = tmpfile(); fd = fileno(pfile);</code></li>
                        <li>如果<code>size</code>为-1, 则改为0, 并初始化分页表. <a href="#PageList-Init"><code>size = 0; pagelist.Init(0, false)</code></a></li>
                        <li>如果<code>size</code>不为-1, 则调整分页表大小, <a href="#PageList-Resize"><code>pagelist.Resize(static_cast&lt;size_t&gt;(size), false)</code></a>.
                            并且对缓存文件执行truncate操作. </li>
                    </ul>
                </li>
                <li>上述操作中如果改动了<a href="#FdEntity-pagelist"><code>pagelist</code></a>, 并且是有缓存目录的模式, 则将其重新序列化保存到stat文件.
                    <ul>
                        <li><a href="#CacheFileStat-CacheFileStat"><code>CacheFileStat cfstat(path.c_str());</code></a></li>
                        <li><a href="#PageList-Serialize"><code>pagelist.Serialize(cfstat, true);</code></a></li>
                    </ul>
                </li>
                <li>设置引用数<a href="#FdEntity-refcnt"><code>refcnt</code></a>为1</li>
                <li>设置修改标记<a href="#FdEntity-is_modify"><code>is_modify</code></a>为false</li>
                <li>根据<code>pmeta</code>更新<a href="#FdEntity-orgmeta"><code>orgmeta</code></a>和<a href="#FdEntity-size_orgmeta"><code>size_orgmeta</code></a></li>
                <li>如果<code>time</code>不为-1, <a href="#FdEntity-SetMtime"><code>SetMtime(time)</code></a></li>
            </ul>
        </div>

        <div class="func" id="FdEntity-Close">
            <div class="name"><code>void FdEntity::Close(void)</code></div>
            <div class="desc">
                关闭文件
            </div>
            <ul class="impl">
                <li>如果<a href="#FdEntity-fd"><code>fd == -1</code></a>, 不用执行任何操作</li>
                <li>修改引用数, <a href="#FdEntity-refcnt"><code>refcnt --;</code></a></li>
                <li>如果引用为0 (<code>refcnt == 0</code>), 彻底关闭文件并重置变量.
                    <ul>
                        <li>如果有缓存目录, 则序列化分页表. <a href="#PageList-Serialize"><code>pagelist.Serialize(cfstat, true)</code></a></li>
                        <li>关闭文件<code>fclose(pfile); pfile = NULL; fd = -1;</code></li>
                        <li>如果有镜像文件, <code>unlink(mirrorpath.c_str()); mirrorpath.erase();</code></li>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="func" id="FdEntity-Read">
            <div class="name"><code>ssize_t FdEntity::Read(char* bytes, off_t start, size_t size, bool force_load)</code></div>
            <div class="desc">
                读文件, 从<code>start</code>开始读取<code>size</code> bytes. <br/>
                <code>force_load</code> 是否强制从云端加载 <br/>
            </div>
            <ul class="impl">
                <li>如果<a href="#FdEntity-fd"><code>fd == -1</code></a>, 返回<code>-EBADF</code></li>
                <li>如果<code>force_load</code>, 设置读取部分的loaded状态为false从而强制重新从云端加载. <a href="#PageList-SetPageLoadedStatus"><code>pagelist.SetPageLoadedStatus(start, size, false);</code></a></li>
                <li>如果有需要从云端加载的内容, (<a href="#PageList-GetTotalUnloadedPageSize"><code>0 < pagelist.GetTotalUnloadedPageSize(start, size)</code></a>),
                    <ul>
                        <li>如果磁盘空间不足, (<a href="#FdManager-IsSafeDiskSpace"><code>!FdManager::IsSafeDiskSpace(NULL, size)</code></a>),
                            这里传入<code>size</code>是否不合适? 应该传入需要加载的大小? <br/>
                            且文件未被修改, (<a href="#FdEntity-is_modify"><code>!is_modify</code></a>), <br/>
                            则清空文件缓存以腾出磁盘空间.
                            <ul>
                                <li>全部标记为unloaded<a href="#PageList-Init"><code>pagelist.Init(pagelist.Size(), false)</code></a></li>
                                <li>truncate缓存文件, <code>ftruncate(fd, 0); ftruncate(fd, pagelist.Size());</code></li>
                            </ul>
                            (若磁盘空间不足而文件已经被修改, 则读文件操作只能以失败告终)
                        </li>
                    </ul>
                </li>
                <li>计算加载的大小<code>load_size</code>, 因为读取一般都是连续操作, 所以一次性加载尽量多的内容. <br/>
                    <ul>
                        <li>一次最多加载的大小为<a href="curl.html#S3fsCurl-multipartsize"><code>prefetch_max_size = S3fsCurl::GetMultipartSize() * S3fsCurl::GetMaxParallelCount()</code></a></li>
                        <li>如果从<code>start</code>开始加载<code>prefetch_max_size</code>大小的内容未超出文件实际总长度<a href="#PageList-Size"><code>pagelist.Size()</code></a>, 则<code>load_size = prefetch_max_size</code></li>
                        <li>否则<code>load_size = pagelist.Size() - start</code></li>
                    </ul>
                </li>
                <li>加载内容, <a href="#FdEntity-Load"><code>Load(start, load_size)</code></a></li>
                <li>读文件, <code>rsize = pread(fd, bytes, size, start)</code></li>
            </ul>
        </div>

        <div class="func" id="FdEntity-Write">
            <div class="name"><code>ssize_t FdEntity::Write(const char* bytes, off_t start, size_t size)</code></div>
            <div class="desc">
                写文件, 写入<code>bytes</code>从<code>start</code>(bytes)开始的<code>size</code>个byte. 返回写入的字节数.
            </div>
            <ul class="impl">
                <li>如果<a href="#FdEntity-fd"><code>fd == -1</code></a>, 返回<code>-EBADF</code></li>
                <li>如果文件大小比<code>start</code>要小, <a href="#PageList-Size"><code>pagelist.Size() < static_cast&lt;size_t&gt;(start)</code></a>.
                    <ul>
                        <li>扩充文件大小, <code>ftruncate(fd, static_cast&lt;size_t&gt;(start))</code></li>
                        <li>扩展分页表<a href="#FdEntity-pagelist"><code>pagelist</code></a>的大小, <a href="#PageList-SetPageLoadedStatus"><code>pagelist.SetPageLoadedStatus(static_cast&lt;off_t&gt;(pagelist.Size()), static_cast&lt;size_t&gt;(start) - pagelist.Size(), false);</code></a></li>
                    </ul>
                </li>
                <li>如果没有开始multipart uploading(<a href="#FdEntity-upload_id"><code>0 == upload_id.length()</code></a>), 初始化multipart uploading
                    <ul>
                        <li>计算需要的磁盘空间, <a href="#PageList-GetTotalUnloadedPageSize"><code>size_t restsize = pagelist.GetTotalUnloadedPageSize(0, start) + size;</code></a> </li>
                        <li>如果磁盘空间足够(<a href="#FdManager-IsSafeDiskSpace"><code>FdManager::IsSafeDiskSpace(NULL, restsize)</code>)</a>,
                            则加载从0一直到start位置的数据. <a href="#FdEntity-Load"><code>Load(0, static_cast&lt;size_t&gt;(start)</code></a>
                        </li>
                        <li>否则(磁盘空间不够),
                            <ul>
                                <li><a href="#FdEntity-NoCachePreMultipartPost"><code>NoCachePreMultipartPost()</code></a></li>
                                <li><a href=#FdEntity-NoCacheLoadAndPost"><code>NoCacheLoadAndPost(0, start)</code></a></li>
                                <li><a href="#FdEntity-mp_start"><code>mp_start = start</code></a></li>
                                <li><a href="#FdEntity-mp_size"><code>mp_size = 0</code></a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>写文件, <code>wsize = pwrite(fd, bytes, size, start)</code></li>
                <li><a href="#FdEntity-is_modify"><code>is_modify = true</code></a></li>
                <li>如果<code>0 < wsize</code>, 设置写入的部分loaded标志为true. <a href="#PageList-SetPageLoadedStatus"><code>pagelist.SetPageLoadedStatus(start, static_cast&lt;size_t&gt;(wsize), true)</code></a></li>
                <li>如果<code>0 < upload_id.length()</code>, 正在multipart上传, 将新写入的内容也上传.
                    <ul>
                        <li><a href="#FdEntity-mp_size"><code>mp_size += static_cast&lt;size_t&gt;(wsize)</code></a></li>
                        <li>如果<a href="curl.html#S3fsCurl-multipart_size"><code>static_cast&lt;size_t&gt;(S3fsCurl::GetMultipartSize()) <= mp_size</code></a>
                            <ul>
                                <li><a href="#FdEntity-NoCacheMultipartPost"><code>NoCacheMultipartPost(fd, mp_start, mp_size)</code></a></li>
                                <li>清空文件但保持长度, 不占用磁盘空间. <code>ftruncate(fd, 0); ftruncate(fd, mp_start+mp_size);</code></li>
                                <li><a href="#FdEntity-mp_start"><code>mp_start += mp_size</code></a></li>
                                <li><a href="#FdEntity-mp_size"><code>mp_size = 0</code></a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="func" id="FdEntity-RowFlush">
            <div class="name"><code>int FdEntity::RowFlush(const char* tpath, bool force_sync)</code></div>
            <ul class="impl">
                <li>如果<a href="#FdEntity-fd"><code>fd == -1</code></a>, 返回<code>-EBADF</code></li>
                <li>如果不是强制同步(<code>force_sync</code>)且文件未修改(<a href="#FdEntity-is_modify"><code>is_modify</code></a>), 则直接返回0</li>
                <li>如果还存在要从云端加载的部分, <a href="#PageList-GetTotalUnloadedPageSize"><code>restsize = pagelist.GetTotalUnloadedPageSize()</code></a>
                    <ul>
                        <li>如果未开始multipart uploading (<a href="#FdEntity-upload_id"><code>upload_id.length() == 0</code></a>,
                            <ul>
                                <li>如果磁盘空间足够, <a href="#FdManager-IsSafeDiskSpace"><code>FdManager::IsSafeDiskSpace(NULL, restsize)</code></a>, 则加载剩余内容, <a href="#FdEntity-Load"><code>Load()</code></a></li>
                                <li>否则(磁盘空间不够), 开始加载同时multipart uploading, <a href="#FdEntity-NoCacheLoadAndPost"><code>NoCacheLoadAndPost()</code></a></li>
                            </ul>
                        </li>
                    </ul>
                </li>
                <li>如果不是multipart uploading模式 (<a href="#FdEntity-upload_id"><code>upload_id.length() == 0</code></a>,
                    <ul>
                        <li>如果文件大小太大, 超过<a href="curl.html#S3fsCurl-multipart_size"><code>MAX_MULTIPART_CNT * S3fsCurl::GetMultipartSize()</code></a>, 返回<code>-ENOTSUP</code></li>
                        <li>获取文件attributes, <code>fstat(fd, &st)</code>, 用于稍后更新文件大小记录</li>
                        <li>文件指针置于头部, lseek(fd, 0, SEEK_SET)</li>
                        <li>如果文件大小超过<a href="curl.html#S3fsCurl-multipart_size"><code>2 * S3fsCurl::GetMultipartSize()</code></a>, 且没有被全局禁止multipart uploading,
                            <ul>
                                <li>若curl读写请求超时时间<a href="curl.html#S3fsCurl-readwrite_timeout"><code>readwrite_timeout</code></a>大于120s, 设置超时时间为120s</li>
                                <li><a href="curl.html#S3fsCurl-ParallelGetObjectRequest"><code>S3fsCurl::ParallelGetObjectRequest(path.c_str(), fd, (*iter)->offset, need_load_size)</code></a></li>
                                <li>还原超时时间设置.</li>
                            </ul>
                        </li>
                        <li>否则, 单一请求上传.
                            <ul>
                                <li><a href="curl.html#S3fsCurl-S3fsCurl"><code>S3fsCurl s3fscurl(true);</code></a></li>
                                <li><a href="curl.html#S3fsCurl-PutRequest"><code>s3fscurl.PutRequest(tpath ? tpath : path.c_str(), orgmeta, fd);</code></a></li>
                            </ul>
                        </li>
                        <li>文件指针置于头部, lseek(fd, 0, SEEK_SET)</li>
                        <li>更新云端文件大小记录, <a href="#FdEntity-size_orgmeta"><code>size_orgmeta = static_cast&lt;size_t&gt;(st.st_size);</code></a></li>
                    </ul>
                </li>
                <li>否则(是multipart uploading模式), 则上传剩余的部分.
                    <ul>
                        <li>如果<a href="#FdEntity-mp_size"><code>mp_size > 0</code></a>, 上传当前part, <a href="#FdEntity-NoCacheMultipartPost"><code>NoCacheMultipartPost(fd, mp_start, mp_size)</code></a></li>
                        <li>上传剩余部分, <a href="#FdEntity-NoCacheCompleteMultipartPost"><code>NoCacheCompleteMultipartPost()</code></a></li>
                        <li><code>ftruncate(fd, 0)</code></li>
                    </ul>
                </li>
                <li>重置修改标记<a href="#FdEntity-is_modify"><code>is_modify</code></a>为false.</li>
            </ul>
            <div class="remark">
                NoCacheMultipar upload完为什么要truncate file to zero? 不用将文件再truncate改为正确的长度?
            </div>
        </div>

        <div class="func" id="FdEntity-Load">
            <div class="name"><code>int FdEntity::Load(off_t start, size_t size)</code></div>
            <div class="desc">
                从云上下载文件内容, 从<code>start</code> (bytes)位置开始, 大小<code>size</code> bytes
            </div>
            <ul class="impl">
                <li>如果<a href="#FdEntity-fd"><code>fd == -1</code></a>, 返回<code>-EBADF</code></li>
                <li>查找所有要加载的片段, <a href="#PageList-GetUnloadedPages"><code>pagelist.GetUnloadedPages(unloaded_list, start, size)</code></a></li>
                <li>遍历所有要加载的片段, 对于每一个片段<code>*iter</code>,
                    <ul>
                        <li>根据<a href="#FdEntity-orgmeta"><code>size_orgmeta</code></a>计算需要下载的大小<code>need_load_size</code>和超出部分的大小<code>over_size</code></li>
                        <li>如果可以使用multipart, 且<code>2 * S3fsCurl::GetMultipartSize() < need_load_size</code>, 则采用multipart方式下载.
                            <ul>
                                <li>若curl读写请求超时时间<a href="curl.html#S3fsCurl-readwrite_timeout"><code>readwrite_timeout</code></a>大于120s, 设置超时时间为120s</li>
                                <li><a href="curl.html#S3fsCurl-ParallelGetObjectRequest"><code>S3fsCurl::ParallelGetObjectRequest(path.c_str(), fd, (*iter)->offset, need_load_size)</code></a></li>
                                <li>还原超时时间设置.</li>
                            </ul>
                        </li>
                        <li>否则使用single request下载, <a href="curl.html#S3fsCurl-GetObjectRequest"><code>s3fscurl.GetObjectRequest(path.c_str(), fd, (*iter)->offset, need_load_size)</code></a></li>
                        <li>对于超出部分<code>over_size</code>, 用0填充文件. <a href="#FdEntity-FillFile"><code>FdEntity::FillFile(fd, 0, over_size, (*iter)->offset + need_load_size)</code></a></li>
                        <li>设置此片段加载状态为true, <a href="#PageList-SetPageLoadedStatus"><code>pagelist.SetPageLoadedStatus((*iter)->offset, static_cast&lt;off_t&gt;((*iter)->bytes), true)</code></a> </li>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="func" id="FdEntity-NoCachePreMultipartPost">
            <div class="name"><code>int FdEntity::NoCachePreMultipartPost(void)</code></div>
            <div class="desc">
                开始multipart上传请求
            </div>
            <ul class="impl">
                <li>初始化, <a href="#FdEntity-upload_id"><code>upload_id.erase()</code></a></li>
                <li>初始化, <a href="#FdEntity-etaglist"><code>etaglist.clear()</code></a></li>
                <li><a href="curl.html#S3fsCurl-S3fsCurl"><code>S3fsCurl s3fscurl(true)</code></a></li>
                <li><a href="curl.html#S3fsCurl-PreMultipartPostRequest"><code>s3fscurl.PreMultipartPostRequest(path.c_str(), orgmeta, upload_id, false)</code></a></li>
                <li><a href="curl.html#S3fsCurl-DestroyCurlHandle"><code>s3fscurl.DestroyCurlHandle()</code></a></li>
            </ul>
        </div>

        <div class="func" id="FdEntity-NoCacheMultipartPost">
            <div class="name"><code>int FdEntity::NoCacheMultipartPost(int tgfd, off_t start, size_t size)</code></div>
            <div class="desc">
                multipart上传
            </div>
            <ul class="impl">
                <li>检查multipart上传的初始化, <code>-1 != tgfd && !upload_id.empty()</code></li>
                <li><a href="curl.html#S3fsCurl-S3fsCurl"><code>S3fsCurl s3fscurl(true)</code></a></li>
                <li><a href="curl.html#S3fsCurl-MultipartUploadRequest"><code>s3fscurl.MultipartUploadRequest(upload_id, path.c_str(), tgfd, start, size, etaglist)</code></a></li>
            </ul>
        </div>

        <div class="func" id="FdEntity-NoCacheLoadAndPost">
            <div class="name"><code>int FdEntity::NoCacheLoadAndPost(off_t start, size_t size)</code></div>
            <div class="desc">
                在磁盘空间不足的情况下调用此方法, 加载object内容同时上传.
            </div>
            <ul class="impl">
                <li>此方法被调用说明缓存文件不会再被用到, 故清除缓存文件.
                    <ul>
                        <li><a href="#FdManager-DeleteCacheFile"><code>FdManager::DeleteCacheFile(path.c_str())</code></a></li>
                        <li><a href="#FdEntity-cachepath"><code>cachepath.erase()</code></a></li>
                        <li><a href="#FdEntity-mirrorpath"><code>mirrorpath.erase()</code></a></li>
                    </ul>
                </li>
                <li>将此Entity在<code>FdManager</code>中的mapping key改成随机路径, <a href="#FdManager-ChangeEntityToTempPath"><code>FdManager::get()->ChangeEntityToTempPath(this, path.c_str())</code></a></li>
                <li>打开临时文件<code>ptmpfp = tmpfile(); tmpfd = fileno(ptmpfp);</code></li>
                <li></li>
                ...
            </ul>
        </div>

        <div class="func" id="FdEntity-Dup">
            <div class="name"><code>int FdEntity::Dup(void)</code></div>
            <div class="desc">
                如果已经打开本地文件(<a href="#FdEntity-fd"><code>fd</code></a> != -1), 则<a href="#FdEntity-refcnt"><code>refcnt++</code></a>
            </div>
        </div>

        <div class="func" id="FdEntity-SetMtime">
            <div class="name"><code>int FdEntity::SetMtime(time_t time)</code></div>
            <div class="desc">
                修改文件的access time和modification time
            </div>
            <ul class="impl">
                <li>如果已经打开了缓存文件或临时文件, 用<code>futimes(fd, tv)</code>函数修改文件的access time和modification time均为<code>time</code></li>
                <li>如果未打开缓存文件, 如果是有缓存文件(<code>0 < cachepath.size()</code>), 用<code>utime(cachepath.c_str(), &n_mtime)</code>函数修改缓存文件的access time和modification time均为<code>time</code></li>
                <li>修改<a href="#FdEntity-orgmeta"><code>orgmeta</code></a>. <code>orgmeta["x-amz-meta-mtime"] = str(time)</code></li>
            </ul>
        </div>

        <div class="func" id="FdEntity-UpdateMtime">
            <div class="name"><code>bool FdEntity::UpdateMtime(void)</code></div>
            <div class="desc">
                根据当前文件的attr信息更新<a href="#FdEntity-orgmeta"><code>orgmeta</code></a>的mtime字段
            </div>
            <ul class="impl">
                <li><a href="#FdEntity-GetStats"><code>GetStats(st)</code></a> </li>
                <li><a href="#FdEntity-orgmeta"><code>orgmeta["x-amz-meta-mtime"] = str(st.st_mtime)</code></a></li>
            </ul>
        </div>

        <div class="func" id="FdEntity-GetStats">
            <div class="name"><code>bool FdEntity::GetStats(struct stat& st)</code></div>
            <div class="desc">
                获得当前文件的attr (struct stat), 存到<code>st</code>中.
            </div>
            <ul class="impl">
                <li>如果<a href="#FdEntity-fd"><code>fd == -1</code></a>, 返回false</li>
                <li><code>memset(&st, 0, sizeof(struct stat))</code></li>
                <li><code>fstat(fd, &st)</code></li>
            </ul>
        </div>

        <div class="func" id="FdEntity-GetSize">
            <div class="name"><code>bool FdEntity::GetSize(size_t& size)</code></div>
            <ul class="impl">
                <li>如果<a href="#FdEntity-fd"><code>fd == -1</code></a>, 返回false</li>
                <li><a href="#PageList-Size"><code>size = pagelist.Size()</code></a></li>
            </ul>
        </div>

        <div class="func" id="FdEntity-SetMode">
            <div class="name"><code>bool FdEntity::SetMode(mode_t mode)</code></div>
            <ul class="impl">
                <li><a href="#FdEntity-orgmeta"><code>orgmeta["x-amz-meta-mode"] = str(mode)</code></a></li>
            </ul>
        </div>

        <div class="func" id="FdEntity-SetUId">
            <div class="name"><code>bool FdEntity::SetUId(uid_t uid)</code></div>
            <ul class="impl">
                <li><a href="#FdEntity-orgmeta"><code>orgmeta["x-amz-meta-uid"] = str(uid)</code></a></li>
            </ul>
        </div>

        <div class="func" id="FdEntity-SetGId">
            <div class="name"><code>bool FdEntity::SetGId(gid_t gid)</code></div>
            <ul class="impl">
                <li><a href="#FdEntity-orgmeta"><code>orgmeta["x-amz-meta-gid"] = str(gid)</code></a></li>
            </ul>
        </div>

        <div class="func" id="FdEntity-SetContentType">
            <div class="name"><code>bool FdEntity::SetContentType(const char* path)</code></div>
            <ul class="impl">
                <li><a href="curl.html#S3fsCurl-LookupMimeType"><code>orgmeta["Content-Type"] = S3fsCurl::LookupMimeType(string(path));</code></a></li>
            </ul>
        </div>

        <div class="func" id="FdEntity-FillFile">
            <div class="name"><code>int FdEntity::FillFile(int fd, unsigned char byte, size_t size, off_t start)</code></div>
            <div class="desc">
                静态方法, 填充文件. <br/>
                <code>fd</code> 文件描述符 <br/>
                <code>byte</code> 填充字节 <br/>
                <code>size</code> 填充大小 <br/>
                <code>start</code> 起始位置 <br/>
            </div>
        </div>

    </div>

    <div class="section" id="PageList">
        <h3>PageList</h3>
        <div class="desc">
            维护一个页链表, 标记各个页的起始位置, 长度, 是否已加载. 用于分页加载和上传object.
        </div>
        <div class="attrs">
            相关定义:
<pre id="fdpage">// page block information
struct fdpage
{
  off_t  offset;
  size_t bytes;
  bool   loaded;

  fdpage(off_t start = 0, size_t size = 0, bool is_loaded = false)
           : offset(start), bytes(size), loaded(is_loaded) {}

  off_t next(void) const { return (offset + bytes); }
  off_t end(void) const { return (0 &lt; bytes ? offset + bytes - 1 : 0); }
};
typedef std::list&lt;struct fdpage*&gt; fdpage_list_t;
</pre>
            成员变量:
            <div class="attr" id="PageList-pages">
                <div class="name"><code>fdpage_list_t pages;</code></div>
            </div>
        </div>

        <div class="func" id="PageList-Init">
            <div class="name"><code>bool PageList::Init(size_t size, bool is_loaded)</code></div>
            <div class="desc">
                初始化PageList <br/>
                <code>size</code> 总大小 <br/>
                <code>is_loaded</code> 是否已加载 <br/>
            </div>
            <ul class="impl">
                <li>清空<a href="#PageList-pages"><code>pages</code></a></li>
                <li>新建<a href="#fdpage"><code>new fdpage(0, size, is_loaded)</code></a>并添加到<a href="#PageList-pages"><code>pages</code></a></li>
            </ul>
        </div>

        <div class="func" id="PageList-Size">
            <div class="name">size_t PageList::Size(void) const</div>
            <div class="desc">
                获取当前的总大小
            </div>
            <ul class="impl">
                <li>如果<a href="#PageList-pages"><code>pages</code></a>为空, 返回0</li>
                <li>否则找到<a href="#PageList-pages"><code>pages</code></a>最后一个元素 <code>fdpage_list_t::const_reverse_iterator riter = pages.rbegin();</code></li>
                <li>返回<code>static_cast&lt;size_t&gt;((*riter)->next())</code></li>
            </ul>
        </div>

        <div class="func" id="PageList-Compress">
            <div class="name"><code>bool PageList::Compress(void)</code></div>
            <div class="desc">
                压缩pagelist, 将连续的未加载的page, 或者连续的已加载的page合并为一个page, 从而减少pagelist的长度.
            </div>
        </div>

        <div class="func" id="PageList-Parse">
            <div class="name"><code>bool PageList::Parse(off_t new_pos)</code></div>
            <div class="desc">
                保证<a href="#PageList-pages"><code>pages</code></a>中包含一页从<code>new_pos</code>开始的page
            </div>
            <ul class="impl">
                <li>遍历<a href="#PageList-pages"><code>pages</code></a>找到包含<code>new_pos</code>的一页page</li>
                <li>如果<code>new_pos</code>为该页的开头, 则直接返回成功</li>
                <li>如果<code>new_pos</code>在该页中间部位, 则从这个位置将该页拆分为两页, 后一页从<code>new_pos</code>开始</li>
            </ul>
        </div>

        <div class="func" id="PageList-Resize">
            <div class="name"><code>bool PageList::Resize(size_t size, bool is_loaded)</code></div>
            <div class="desc">
                调整大小 <br/>
                <code>size</code> 新的大小. <br/>
                <code>is_loaded</code> 新增的部分是否已加载. <br/>
            </div>
            <ul class="impl">
                <li>获取当前的大小. <a href="#PageList-Size"><code>size_t total = Size();</code></a></li>
                <li>根据当前大小和新的<code>size</code>选择以下操作
                    <ul>
                        <li>如果当前大小为0, <a href="#PageList-Init"><code>Init(size, is_loaded);</code></a></li>
                        <li>如果当前大小(<code>total</code>)小于新大小(<code>size</code>).
                            新建<a href="#fdpage"><code>new fdpage(static_cast&lt;off_t&gt;(total), (size - total), is_loaded)</code></a>并添加到pages结尾.
                        </li>
                        <li>如果当前大小(<code>total</code>)大于新大小(<code>size</code>).
                            遍历<a href="#PageList-pages"><code>pages</code></a>, 根据新大小截断并删除多余的项目.
                        </li>
                    </ul>
                </li>
                <li>压缩分页链表<a href="#PageList-Compress"><code>Compress()</code></a></li>
            </ul>
        </div>

        <div class="func" id="PageList-IsPageLoaded">
            <div class="name"><code>bool PageList::IsPageLoaded(off_t start, size_t size) const</code></div>
            <div class="desc">
                查询从start开始大小size的一段是否以加载.
            </div>
            <ul class="impl">
                <li>遍历<a href="#PageList-pages"><code>pages</code></a>以查找包含<code>(start, size)</code>这一段的所有页</li>
                <li>上述页任意一页未加载则返回false, 否则返回true</li>
            </ul>
        </div>

        <div class="func" id="PageList-SetPageLoadedStatus">
            <div class="name"><code>bool PageList::SetPageLoadedStatus(off_t start, size_t size, bool is_loaded, bool is_compress)</code></div>
            <div class="desc">
                设置从<code>start</code>开始大小<code>size</code>的一段的加载状态为<code>is_loaded</code>. <br/>
                <code>is_compress</code> 结束标记后是否进行压缩操作.
            </div>
            <ul class="impl">
                <li>获取当前的大小. <a href="#PageList-Size"><code>size_t now_size = Size();</code></a></li>
                <li>如果<code>start >= now_size </code>, 通过<a href="#PageList-Resize"><code>Resize</code></a>函数实现扩容同时标记<code>is_loaded</code>
                    <ul>
                        <li><a href="#PageList-Resize"><code>Resize(static_cast&lt;size_t&gt;(start), false);</code></a></li>
                        <li><a href="#PageList-Resize"><code>Resize(static_cast&lt;size_t&gt;(start + size), is_loaded);</code></a></li>
                    </ul>
                </li>
                <li>如果<code>start < now_size</code>在当前范围内, 而<code>start+size >= now_size</code>,
                    用<a href="#PageList-Resize"><code>Resize</code></a>先压缩再扩容实现标记<code>is_loaded</code>
                    <ul>
                        <li><a href="#PageList-Resize"><code>Resize(static_cast&lt;size_t&gt;(start), false);</code></a></li>
                        <li><a href="#PageList-Resize"><code>Resize(static_cast&lt;size_t&gt;(start + size), is_loaded);</code></a></li>
                    </ul>
                </li>
                <li>否则说明片段的两段都在当前大小内,
                    <ul>
                        <li>保证分页中包含从<code>start</code>开始的一页. <a href="#PageList-Parse"><code>Parse(start);</code></a></li>
                        <li>保证分页中包含从<code>start+size</code>开始的一页. <a href="#PageList-Parse"><code>Parse(start+size);</code></a></li>
                        <li>标记<code>(start, size)</code>片段包含的所有页的加载状态为<code>is_loaded</code></li>
                    </ul>
                </li>
                <li>如果<code>is_compress</code>, 压缩分页链表, <a href="#PageList-Compress"><code>Compress()</code></a></li>
            </ul>
            <div class="remark">
                其实选择分支的前两个可以合并.
            </div>
        </div>

        <div class="func" id="PageList-FindUnloadedPage">
            <div class="name"><code>bool PageList::FindUnloadedPage(off_t start, off_t& resstart, size_t& ressize) const</code></div>
            <div class="desc">
                查找<code>start</code>位置之后第一个未加载的的分页. <code>start</code>是指该分页包含<code>start</code>位置以后的部分.
                <code>resstart</code>为找到的分页的开始位置. (可能小于start, 只要该分页结尾不小于start)
                <code>ressize</code>为找到的分页的大小.  (必然满足start <= resstart + ressize - 1)
            </div>
        </div>

        <div class="func" id="PageList-GetTotalUnloadedPageSize">
            <div class="name"><code>size_t PageList::GetTotalUnloadedPageSize(off_t start, size_t size) const</code></div>
            <div class="desc">
                统计从<code>start</code>开始长度为<code>size</code>的片段内未加载的部分的总大小. <br/>
                通过遍历<a href="#PageList-pages"><code>pages</code></a>统计实现.
            </div>
        </div>

        <div class="func" id="PageList-GetUnloadedPages">
            <div class="name"><code>int PageList::GetUnloadedPages(fdpage_list_t& unloaded_list, off_t start, size_t size) const</code></div>
            <div class="desc">
                计算从<code>start</code>开始长度为<code>size</code>的片段内, 未加载的分页列表<code>unloaded_list</code>. <br/>
                注意<code>unloaded_list</code>中的分页未必是<a href="#PageList-pages"><code>pages</code></a>中确实存在的分页. 仅表示这些分页部分是未加载的. <br/>
                <code>size</code>为0表示从<code>start</code>开始到文件结尾. <br/>
            </div>
            <ul class="impl">
                <li>如果<code>size == 0</code>, 根据文件总大小修改size使得<code>start + size</code>刚好为文件结尾</li>
                <li>计算目标片段的结束位置<code> next = static_cast&lt;off_t&gt;(start + size)</code></li>
                <li>遍历<a href="#PageList-pages"><code>pages</code></a>, 对于和<code>(start, size)</code>片段有交集的未加载的分页<code>(*iter)</code>:
                    <ul>
                        <li>生成需要加载的分页, 起始位置为<code>max((*iter)->offset, start)</code>
                            结束位置为<code>min((*iter)->next(), next)</code>
                        </li>
                        <li>如果生成的分页和<code>unloaded_list</code>最后一个分页是连续的, 直接合并进上一个分页</li>
                        <li>否则加入到<code>unloaded_list</code>结尾</li>
                    </ul>
                </li>
                <li>返回<code>unloaded_list.size()</code></li>
            </ul>
        </div>

        <div class="func" id="PageList-Serialize">
            <div class="name"><code>bool PageList::Serialize(CacheFileStat& file, bool is_output)</code></div>
            <div class="desc">
                序列化<code>PageList</code> <br/>
                <code>file</code> 用于序列化的文件 <br/>
                <code>is_output</code> 序列化到输出文件还是从文件读取. <br/>
            </div>
            <ul class="impl">
                <li>打开缓存文件<a href="#CacheFileStat-Open"><code>file.Open()</code></a>, 若失败直接返回. </li>
                <li>如果<code>is_output</code>, 序列化输出,
                    <ul>
                        <li>用<code>stringstream ssall</code>生成序列化字符串</li>
                        <li>第一部分是总大小. <a href="#PageList-Size"><code>ssall << Size();</code></a></li>
                        <li>对于<a href="#PageList-pages"><code>pages</code></a>中的每一个分页<code>(*iter)</code>,
                            <code>ssall << "\n" << (*iter)->offset << ":" << (*iter)->bytes << ":" << ((*iter)->loaded ? "1" : "0");</code>
                        </li>
                    </ul>
                </li>
                <li>如果<code>!is_output</code>, 序列化读入,
                    <ul>
                        <li>获取file的大小, 如果为0, 初始化大小为0的<code>PageList</code>并返回. <a href="#PageList-Init">Init(0, false);</a></li>
                        <li>先读取总大小<code>total</code></li>
                        <li>按行读取各个分页并解析<code>offset, size, is_loaded</code>. 然后通过<a href="#PageList-SetPageLoadedStatus"><code>SetPageLoadedStatus(offset, size, is_loaded)</code></a>新建分页</li>
                        <li>检查总大小是否一致. 如果<a href="#PageList-Size"><code>total != Size()</code></a>, 清空分页列表并返回false</li>
                    </ul>
                </li>
            </ul>
        </div>

    </div>

    <div class="section" id="CacheFileStat">
        <h3>CacheFileStat</h3>

        <div class="desc">
            用于管理缓存文件的Stat文件(描述文件?). Stat文件用于序列化PageList, 即保存缓存文件中哪些部分被加载了.
        </div>

        <div class="attrs">
            <div class="attr" id="CacheFileStat-path">
                <span class="name"><code>std::string path;</code></span>
                // 缓存文件的文件路径 <br/>
            </div>

            <div class="attr" id="CacheFileStat-fd">
                <span class="name"><code>int           fd;</code></span>
                // 缓存文件的stat文件的文件描述符 (file descriptor), -1表示还未打开stat文件 <br/>
                <span class="name"><code>int GetFd(void) const { return fd; }</code></span>
            </div>
        </div>

        <div class="func" id="CacheFileStat-DeleteCacheFileStatDirectory">
            <div class="name"><code>bool CacheFileStat::DeleteCacheFileStatDirectory(void)</code></div>
            <div class="desc">
                静态方法, 清空缓存stat文件目录
            </div>
            <ul class="impl">
                <li>如果缓存目录<a href="#FdManager-cache_dir"><code>FdManager::GetCacheDir()</code></a>或者bucket未设置, 直接返回.</li>
                <li>构造缓存stat目录<code>top_path</code>为/[cache_dir]/.[bucket].stat</li>
                <li><a><code>delete_files_in_dir(top_path.c_str(), true)</code></a></li>
            </ul>
        </div>

        <div class="func" id="CacheFileStat-MakeCacheFileStatPath">
            <div class="name"><code>bool CacheFileStat::MakeCacheFileStatPath(const char* path, string& sfile_path, bool is_create_dir)</code></div>
            <div class="desc">
                静态方法, 构造缓存文件的stat文件路径 <br/>
                <code>path</code> 缓存文件路径 <br/>
                <code>sfile_path</code> 构造的stat文件路径 <br/>
                <code>is_create_dir</code> 是否新建路径上的目录 <br/>
                构造的路径为/[cache_dir]/.[bucket].stat/[path] <br/>
            </div>
        </div>

        <div class="func" id="CacheFileStat-CacheFileStat">
            <div class="name"><code>CacheFileStat::CacheFileStat(const char* tpath)</code></div>
            <ul class="impl">
                <li>初始化<a href="#CacheFileStat-fd"><code>fd</code></a>为-1</li>
                <li>初始化<a href="#CacheFileStat-path"><code>path</code></a>为空字符串</li>
                <li>如果<code>tpath</code>非空, <a href="#CacheFileStat-SetPath"><code>SetPath(tpath, true)</code></a></li>
            </ul>
        </div>

        <div class="func" id="CacheFileStat-SetPath">
            <div class="name"><code>bool CacheFileStat::SetPath(const char* tpath, bool is_open)</code></div>
            <div class="desc">
                设置路径为<code>tpath</code> <br/>
                <code>is_open</code> 是否同时执行打开操作 <br/>
            </div>
            <ul class="impl">
                <li>关闭已经打开的旧文件<a href="#CacheFileStat-Release"><code>Release()</code></a></li>
                <li><code>path = tpath;</code></li>
                <li>如果<code>is_open</code>, <a href="#CacheFileStat-Open">Open()</a></li>
            </ul>
        </div>

        <div class="func" id="CacheFileStat-Release">
            <div class="name"><code>bool CacheFileStat::Release(void)</code></div>
            <div class="desc">
                关闭已经打开的文件.
            </div>
        </div>

        <div class="func" id="CacheFileStat-Open">
            <div class="name"><code>bool CacheFileStat::Open(void)</code></div>
            <div class="desc">
                打开文件
            </div>
            <ul class="impl">
                <li>如果<a href="#CacheFileStat-path"><code>path</code></a>为空, 返回false</li>
                <li>如果<a href="#CacheFileStat-fd"><code>fd != -1</code></a>, 说明已经打开, 返回true</li>
                <li>构造stat文件路径<a href="#CacheFileStat-MakeCacheFileStatPath"><code>CacheFileStat::MakeCacheFileStatPath(path.c_str(), sfile_path, true)</code></a></li>
                <li>打开stat文件(新建)<a href="#CacheFileStat-fd"><code>fd = open(sfile_path.c_str(), O_CREAT|O_RDWR, 0600)</code></a></li>
                <li><code>lseek(fd, 0, SEEK_SET)</code></li>
            </ul>
        </div>
    </div>

</div>

</body>
</html>

